// Copyright (C) 2013-2018 Cromwell D. Enage
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_CONCEPT_TRAITS_QUERY_FWD_HPP
#define BOOST_CONCEPT_TRAITS_QUERY_FWD_HPP

//[reference__is_incrementable__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_incrementable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_decrementable__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_decrementable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_boolean_expression__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_boolean_expression;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitmask_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_bitmask_type;
}}}  // namespace boost::concept::traits
//]

//[reference__is_math_real_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_math_real_type;
}}}  // namespace boost::concept::traits
//]

//[reference__is_math_rational_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_math_rational_type;
}}}  // namespace boost::concept::traits
//]

//[reference__is_math_complex_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_math_complex_type;
}}}  // namespace boost::concept::traits
//]

//[reference__is_math_distribution__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_math_distribution;
}}}  // namespace boost::concept::traits
//]

//[reference__is_std_integral_constant__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_std_integral_constant;
}}}  // namespace boost::concept::traits
//]

//[reference__is_std_boolean_constant__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_std_boolean_constant;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_static_constant__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_static_constant;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_boolean_constant__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_boolean_constant;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_integral_constant__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_integral_constant;
}}}  // namespace boost::concept::traits
//]

//[reference__is_rational_constant__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_rational_constant;
}}}  // namespace boost::concept::traits
//]

//[reference__is_argument_pack__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_argument_pack;
}}}  // namespace boost::concept::traits
//]

//[reference__is_accumulator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_accumulator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_optional_pointee__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_optional_pointee;
}}}  // namespace boost::concept::traits
//]

//[reference__is_nullable_pointer__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_nullable_pointer;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_readable_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_readable_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_lvalue_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_lvalue_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_incrementable_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_incrementable_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_input_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_input_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_single_pass_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_single_pass_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_forward_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_forward_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_forward_traversal_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_forward_traversal_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bidirectional_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_bidirectional_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bidirectional_traversal_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_bidirectional_traversal_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_random_access_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_random_access_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_random_access_traversal_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_random_access_traversal_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ptr_map_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_ptr_map_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_allocator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_allocator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_clone_allocator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T, typename U>
    struct is_clone_allocator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_simple_node_handle__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_simple_node_handle;
}}}  // namespace boost::concept::traits
//]

//[reference__is_key_mapped_node_handle__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_key_mapped_node_handle;
}}}  // namespace boost::concept::traits
//]

//[reference__is_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_cxx11_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_cxx11_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_reversible_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_reversible_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_cxx11_reversible_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_cxx11_reversible_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_indexable_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_indexable_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_random_access_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_random_access_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multi_array_index_range__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_multi_array_index_range;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multi_array__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_multi_array;
}}}  // namespace boost::concept::traits
//]

//[reference__is_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_unordered_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_unordered_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_hashed_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_hashed_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_sorted_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_sorted_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_flat_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_flat_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_pair_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_pair_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_unique_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_unique_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multiple_associative_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_multiple_associative_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ptr_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_ptr_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_pair_associative_ptr_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_pair_associative_ptr_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_unique_simple_associative_ptr_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_unique_simple_associative_ptr_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_unique_pair_associative_ptr_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_unique_pair_associative_ptr_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multiple_simple_associative_ptr_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_multiple_simple_associative_ptr_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multiple_pair_associative_ptr_container__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_multiple_pair_associative_ptr_container;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ublas_vector_expression__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_ublas_vector_expression;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ublas_vector__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_ublas_vector;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ublas_matrix_expression__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_ublas_matrix_expression;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ublas_matrix__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_ublas_matrix;
}}}  // namespace boost::concept::traits
//]

//[reference__is_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_back_insertion_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_back_insertion_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_front_insertion_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_front_insertion_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_circular_buffer__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_circular_buffer;
}}}  // namespace boost::concept::traits
//]

//[reference__is_queue__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_queue;
}}}  // namespace boost::concept::traits
//]

//[reference__is_stack_or_std_heap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_stack_or_std_heap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_heap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_heap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iteratable_heap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_iteratable_heap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_order_iteratable_heap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_order_iteratable_heap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mergeable_heap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mergeable_heap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mutable_heap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mutable_heap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_compressed_pair__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_compressed_pair;
}}}  // namespace boost::concept::traits
//]

//[reference__is_half_runtime_pair__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_half_runtime_pair;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_forward_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_forward_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_bidirectional_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_bidirectional_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_random_access_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_random_access_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_forward_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_forward_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_bidirectional_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_bidirectional_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_random_access_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_random_access_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_associative_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_associative_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_extensible_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_extensible_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_front_extensible_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_front_extensible_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_back_extensible_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_mpl_back_extensible_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_forward_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_forward_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_bidirectional_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_bidirectional_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_random_access_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_random_access_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_fusion_associative_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_fusion_associative_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_vertex_list_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_vertex_list_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_edge_list_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_edge_list_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_incidence_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_incidence_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bidirectional_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_bidirectional_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_adjacency_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_adjacency_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_vertex_mutable_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_vertex_mutable_graph;
}}}  // namespace boost::concept::traits
//]

//[reference__is_edge_mutable_graph__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_edge_mutable_graph;
}}}  // namespace boost::concept::traits
//]

#include <boost/concept/policy/use_default.hpp>

//[reference__is_addable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Addend = T
      , typename Sum = ::boost::concept::policy::use_default
    >
    struct is_addable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_subtractable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Subtrahend = T
      , typename Difference = ::boost::concept::policy::use_default
    >
    struct is_subtractable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multipliable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Factor = T
      , typename Product = ::boost::concept::policy::use_default
    >
    struct is_multipliable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_dividable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Divisor = T
      , typename Quotient = ::boost::concept::policy::use_default
    >
    struct is_dividable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_modulo_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Divisor = T
      , typename Remainder = ::boost::concept::policy::use_default
    >
    struct is_modulo_operable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_value_generator__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr = ::boost::concept::policy::use_default
    >
    struct is_value_generator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_value_distribution__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr = ::boost::concept::policy::use_default
    >
    struct is_value_distribution;
}}}  // namespace boost::concept::traits
//]

//[reference__is_value_distribution_with_param__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr = ::boost::concept::policy::use_default
    >
    struct is_value_distribution_with_param;
}}}  // namespace boost::concept::traits
//]

//[reference__is_writable_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Value = ::boost::concept::policy::use_default
    >
    struct is_writable_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_output_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Value = ::boost::concept::policy::use_default
    >
    struct is_output_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bimap__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename LeftPlaceholderExpr = ::boost::concept::policy::use_default
      , typename RightPlaceholderExpr = ::boost::concept::policy::use_default
    >
    struct is_bimap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_readable_property_map__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Key = ::boost::concept::policy::use_default
    >
    struct is_readable_property_map;
}}}  // namespace boost::concept::traits
//]

//[reference__is_writable_property_map__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Key = ::boost::concept::policy::use_default
    >
    struct is_writable_property_map;
}}}  // namespace boost::concept::traits
//]

//[reference__is_read_write_property_map__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Key = ::boost::concept::policy::use_default
    >
    struct is_read_write_property_map;
}}}  // namespace boost::concept::traits
//]

//[reference__is_lvalue_property_map__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Key = ::boost::concept::policy::use_default
    >
    struct is_lvalue_property_map;
}}}  // namespace boost::concept::traits
//]

#include <boost/mpl/bool.hpp>

//[reference__is_indexable_iterator__fwd
namespace boost { namespace concept { namespace traits {

//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
    template <typename T, typename IsStrict = _mpl_false_>
//<-
#else
    template <typename T, typename IsStrict = ::boost::mpl::false_>
#endif
//->
    struct is_indexable_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__is_indexable_traversal_iterator__fwd
namespace boost { namespace concept { namespace traits {

//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
    template <typename T, typename IsStrict = _mpl_false_>
//<-
#else
    template <typename T, typename IsStrict = ::boost::mpl::false_>
#endif
//->
    struct is_indexable_traversal_iterator;
}}}  // namespace boost::concept::traits
//]

#include <boost/mpl/placeholders.hpp>

//[reference__is_range__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename PlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_single_pass_iterator_<_mpl_placeholder_>
//<-
#else
        ::boost::concept::traits::is_single_pass_iterator< ::boost::mpl::_>
#endif
//->
    >
    struct is_range;
}}}  // namespace boost::concept::traits
//]

//[reference__is_reversible__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename PlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_bidirectional_iterator_<_mpl_placeholder_>
//<-
#else
        ::boost::concept::traits::is_bidirectional_iterator< ::boost::mpl::_>
#endif
//->
    >
    struct is_reversible;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_mpl_forward_iterator_<_mpl_placeholder_>
//<-
#else
        ::boost::concept::traits::is_mpl_forward_iterator< ::boost::mpl::_>
#endif
//->
    >
    struct is_mpl_sequence;
}}}  // namespace boost::concept::traits
//]

//[reference__is_mpl_associative_sequence__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_mpl_forward_iterator_<_mpl_placeholder_>
//<-
#else
        ::boost::concept::traits::is_mpl_forward_iterator< ::boost::mpl::_>
#endif
//->
    >
    struct is_mpl_associative_sequence;
}}}  // namespace boost::concept::traits
//]

#include <boost/concept/traits/introspection_fwd.hpp>

//[reference__is_complementable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename ResultPlaceholderExpr =
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
          , T
        >
//<-
#else
      , typename ResultPlaceholderExpr = ::boost::concept::traits
        ::is_convertible_to_cref_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_complementable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_identity_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename ResultPlaceholderExpr =
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
          , T
        >
//<-
#else
      , typename ResultPlaceholderExpr = ::boost::concept::traits
        ::is_convertible_to_cref_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_identity_operable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_negatable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename ResultPlaceholderExpr =
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
          , T
        >
//<-
#else
      , typename ResultPlaceholderExpr = ::boost::concept::traits
        ::is_convertible_to_cref_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_negatable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_lvalue_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Value = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_lvalue_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_rvalue_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Value = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_rvalue_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitwise_and_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_bitwise_and_operable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitwise_or_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_bitwise_or_operable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitwise_xor_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_bitwise_xor_operable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_left_shift_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_left_shift_operable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_right_shift_operable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_convertible_to_cref_of_<
            _mpl_placeholder_
//<-
#else
        ::boost::concept::traits::is_convertible_to_cref_of<
            ::boost::mpl::_
#endif
//->
          , T
        >
    >
    struct is_right_shift_operable;
}}}  // namespace boost::concept::traits
//]

#include <boost/concept/traits/introspection/nested_type_fwd.hpp>

//[reference__is_subscriptable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Subscript
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_reference_of_<_mpl_placeholder_,T>
//<-
#else
        ::boost::concept::traits::is_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_subscriptable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_runtime_pair__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename FirstPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_first_type_of_<_mpl_placeholder_,T>
//<-
#else
        ::boost::concept::traits::is_first_type_of< ::boost::mpl::_,T>
#endif
//->
      , typename SecondPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_second_type_of_<_mpl_placeholder_,T>
//<-
#else
        ::boost::concept::traits::is_second_type_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_runtime_pair;
}}}  // namespace boost::concept::traits
//]

#include <boost/config.hpp>

#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
#include <boost/type_traits/add_const.hpp>
#include <boost/type_traits/remove_reference.hpp>
#else
#include <type_traits>
#endif

//[reference__is_additive__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename Difference = typename _std_add_const_<
            typename _std_remove_reference_<T>::type
        >::type
//<-
#elif defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
      , typename Difference = typename ::boost::add_const<
            typename ::boost::remove_reference<T>::type
        >::type
#else
      , typename Difference = typename ::std::add_const<
            typename ::std::remove_reference<T>::type
        >::type
#endif
//->
    >
    struct is_additive;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multiplicative__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename Dividend = typename _std_add_const_<
            typename _std_remove_reference_<T>::type
        >::type
//<-
#elif defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
      , typename Dividend = typename ::boost::add_const<
            typename ::boost::remove_reference<T>::type
        >::type
#else
      , typename Dividend = typename ::std::add_const<
            typename ::std::remove_reference<T>::type
        >::type
#endif
//->
    >
    struct is_multiplicative;
}}}  // namespace boost::concept::traits
//]

//[reference__is_equality_comparable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename U = typename _std_add_const_<
            typename _std_remove_reference_<T>::type
        >::type
//<-
#elif defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
      , typename U = typename ::boost::add_const<
            typename ::boost::remove_reference<T>::type
        >::type
#else
      , typename U = typename ::std::add_const<
            typename ::std::remove_reference<T>::type
        >::type
#endif
//->
    >
    struct is_equality_comparable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_less_than_comparable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename U = typename _std_add_const_<
            typename _std_remove_reference_<T>::type
        >::type
//<-
#elif defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
      , typename U = typename ::boost::add_const<
            typename ::boost::remove_reference<T>::type
        >::type
#else
      , typename U = typename ::std::add_const<
            typename ::std::remove_reference<T>::type
        >::type
#endif
//->
    >
    struct is_less_than_comparable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_comparable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
      , typename U = typename _std_add_const_<
            typename _std_remove_reference_<T>::type
        >::type
//<-
#elif defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
      , typename U = typename ::boost::add_const<
            typename ::boost::remove_reference<T>::type
        >::type
#else
      , typename U = typename ::std::add_const<
            typename ::std::remove_reference<T>::type
        >::type
#endif
//->
    >
    struct is_comparable;
}}}  // namespace boost::concept::traits
//]

#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
#include <boost/type_traits/is_convertible.hpp>
#else
#include <boost/mpl/if.hpp>
#endif

//[reference__is_logically_negatable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_if_<
            _std_is_convertible_<_mpl_placeholder_,bool>
          , _mpl_true_
          , _mpl_false_
        >
//<-
#elif defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_convertible< ::boost::mpl::_,bool>
#else
        ::boost::mpl::if_<
            ::std::is_convertible< ::boost::mpl::_,bool>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif
//->
    >
    struct is_logically_negatable;
}}}  // namespace boost::concept::traits
//]

#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
#include <boost/type_traits/is_same.hpp>
#endif

//[reference__is_pre_incrementable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr = 
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_pre_incrementable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_pre_decrementable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr = 
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_pre_decrementable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_addition_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Addend = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_addition_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_subtraction_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Difference = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_subtraction_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_multiplication_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Factor = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_multiplication_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_division_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Dividend = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_division_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_modulo_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Dividend = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_modulo_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitwise_and_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_bitwise_and_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitwise_or_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_bitwise_or_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_bitwise_xor_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_bitwise_xor_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_left_shift_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_left_shift_assignable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_right_shift_assignable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Operand = ::boost::concept::policy::use_default
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _bct_is_lvalue_reference_of_<_mpl_placeholder_,T>
//<-
#elif defined(BOOST_NO_CXX11_DECLTYPE)
#if defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
        ::boost::is_same< ::boost::mpl::_,T>
#else
        ::boost::mpl::if_<
            ::std::is_same< ::boost::mpl::_,T>
          , ::boost::mpl::true_
          , ::boost::mpl::false_
        >
#endif  // BOOST_NO_CXX11_HDR_TYPE_TRAITS
#else   // !defined(BOOST_NO_CXX11_DECLTYPE)
        ::boost::concept::traits::is_lvalue_reference_of< ::boost::mpl::_,T>
#endif
//->
    >
    struct is_right_shift_assignable;
}}}  // namespace boost::concept::traits
//]

#include <boost/mpl/always.hpp>

//[reference__is_callable__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_callable;
}}}  // namespace boost::concept::traits
//]

//[reference__is_unary_function__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Argument
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_unary_function;
}}}  // namespace boost::concept::traits
//]

//[reference__is_adaptable_unary_function__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_adaptable_unary_function;
}}}  // namespace boost::concept::traits
//]

//[reference__is_binary_function__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename FirstArgument
      , typename SecondArgument
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_binary_function;
}}}  // namespace boost::concept::traits
//]

//[reference__is_adaptable_binary_function__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_adaptable_binary_function;
}}}  // namespace boost::concept::traits
//]

//[reference__is_unary_metafunction_class__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Param
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_unary_metafunction_class;
}}}  // namespace boost::concept::traits
//]

//[reference__is_binary_metafunction_class__fwd
namespace boost { namespace concept { namespace traits {

    template <
        typename T
      , typename Param1
      , typename Param2
      , typename ResultPlaceholderExpr =
//<-
#if defined(BOOST_CONCEPT_CONFIG_DOCUMENTATION)
//->
        _mpl_always_<_mpl_true_>
//<-
#else
        ::boost::mpl::always< ::boost::mpl::true_>
#endif
//->
    >
    struct is_binary_metafunction_class;
}}}  // namespace boost::concept::traits
//]

#endif  // include guard

