// Copyright (C) 2013-2018 Cromwell D. Enage
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_CONCEPT_TRAITS_TRIVIAL_ACCESS_FWD_HPP
#define BOOST_CONCEPT_TRAITS_TRIVIAL_ACCESS_FWD_HPP

//[reference__self_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct self_of;
}}}  // namespace boost::concept::traits
//]

//[reference__tag_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct tag_of;
}}}  // namespace boost::concept::traits
//]

//[reference__type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__const_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct const_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__element_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct element_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__pointer_element_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct pointer_element_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__result_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct result_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__argument_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct argument_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__first_argument_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct first_argument_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__second_argument_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct second_argument_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__param_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct param_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__distribution_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct distribution_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__policy_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct policy_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__first_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct first_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__second_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct second_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__first_param_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct first_param_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__second_param_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct second_param_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__first_reference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct first_reference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__second_reference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct second_reference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__num_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct num_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__den_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct den_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__int_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct int_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__value_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct value_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_traversal_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator_traversal_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_difference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator_difference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_value_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator_value_of;
}}}  // namespace boost::concept::traits
//]

//[reference__reference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct reference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__pointer_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct pointer_of;
}}}  // namespace boost::concept::traits
//]

//[reference__container_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct container_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__char_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct char_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__other_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct other_of;
}}}  // namespace boost::concept::traits
//]

//[reference__void_pointer_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct void_pointer_of;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_pointer_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct allocator_pointer_of;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_difference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct allocator_difference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_size_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct allocator_size_of;
}}}  // namespace boost::concept::traits
//]

//[reference__propagate_on_container_copy_assignment__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct propagate_on_container_copy_assignment;
}}}  // namespace boost::concept::traits
//]

//[reference__propagate_on_container_move_assignment__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct propagate_on_container_move_assignment;
}}}  // namespace boost::concept::traits
//]

//[reference__propagate_on_container_swap__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct propagate_on_container_swap;
}}}  // namespace boost::concept::traits
//]

//[reference__is_always_equal__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct is_always_equal;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_bool_pair_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator_bool_pair_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator1_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator1_of;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator2_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct iterator2_of;
}}}  // namespace boost::concept::traits
//]

//[reference__array_range_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct array_range_of;
}}}  // namespace boost::concept::traits
//]

//[reference__capacity_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct capacity_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__size_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct size_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct allocator_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__auto_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct auto_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__key_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct key_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__mapped_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct mapped_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__node_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct node_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__hasher_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct hasher_of;
}}}  // namespace boost::concept::traits
//]

//[reference__key_equal_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct key_equal_of;
}}}  // namespace boost::concept::traits
//]

//[reference__key_compare_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct key_compare_of;
}}}  // namespace boost::concept::traits
//]

//[reference__value_compare_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct value_compare_of;
}}}  // namespace boost::concept::traits
//]

//[reference__element_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct element_of;
}}}  // namespace boost::concept::traits
//]

//[reference__index_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct index_of;
}}}  // namespace boost::concept::traits
//]

//[reference__index_gen_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct index_gen_of;
}}}  // namespace boost::concept::traits
//]

//[reference__index_range_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct index_range_of;
}}}  // namespace boost::concept::traits
//]

//[reference__left_map_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct left_map_of;
}}}  // namespace boost::concept::traits
//]

//[reference__right_map_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct right_map_of;
}}}  // namespace boost::concept::traits
//]

//[reference__reverse_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct reverse_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__reverse_iterator1_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct reverse_iterator1_of;
}}}  // namespace boost::concept::traits
//]

//[reference__reverse_iterator2_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct reverse_iterator2_of;
}}}  // namespace boost::concept::traits
//]

//[reference__ordered_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct ordered_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__handle_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct handle_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__expression_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct expression_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__type_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct type_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__vertex_descriptor_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct vertex_descriptor_of;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_descriptor_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct edge_descriptor_of;
}}}  // namespace boost::concept::traits
//]

//[reference__vertices_size_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct vertices_size_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__edges_size_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct edges_size_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__degree_size_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct degree_size_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__vertex_property_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct vertex_property_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_property_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct edge_property_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__vertex_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct vertex_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct edge_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__out_edge_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct out_edge_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__in_edge_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct in_edge_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__adjacency_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct adjacency_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__traversal_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct traversal_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__directed_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct directed_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_parallel_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct edge_parallel_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__event_filter_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct event_filter_of;
}}}  // namespace boost::concept::traits
//]

//[reference__next_to__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct next_to;
}}}  // namespace boost::concept::traits
//]

//[reference__prior_to__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct prior_to;
}}}  // namespace boost::concept::traits
//]

//[reference__result_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct result_of;
}}}  // namespace boost::concept::traits
//]

#include <boost/config.hpp>

#if defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)

namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct self_of_t;

    template <typename T>
    struct tag_of_t;

    template <typename T>
    struct type_of_t;

    template <typename T>
    struct const_type_of_t;

    template <typename T>
    struct element_type_of_t;

    template <typename T>
    struct pointer_element_type_of_t;

    template <typename T>
    struct result_type_of_t;

    template <typename T>
    struct argument_type_of_t;

    template <typename T>
    struct first_argument_type_of_t;

    template <typename T>
    struct second_argument_type_of_t;

    template <typename T>
    struct param_type_of_t;

    template <typename T>
    struct distribution_type_of_t;

    template <typename T>
    struct policy_type_of_t;

    template <typename T>
    struct first_type_of_t;

    template <typename T>
    struct second_type_of_t;

    template <typename T>
    struct num_type_of_t;

    template <typename T>
    struct den_type_of_t;

    template <typename T>
    struct int_type_of_t;

    template <typename T>
    struct value_type_of_t;

    template <typename T>
    struct iterator_category_of_t;

    template <typename T>
    struct iterator_traversal_of_t;

    template <typename T>
    struct iterator_difference_of_t;

    template <typename T>
    struct iterator_value_of_t;

    template <typename T>
    struct reference_of_t;

    template <typename T>
    struct pointer_of_t;

    template <typename T>
    struct container_type_of_t;

    template <typename T>
    struct char_type_of_t;

    template <typename T>
    struct other_of_t;

    template <typename T>
    struct void_pointer_of_t;

    template <typename T>
    struct allocator_pointer_of_t;

    template <typename T>
    struct allocator_difference_of_t;

    template <typename T>
    struct allocator_size_of_t;

    template <typename T>
    struct iterator_bool_pair_of_t;

    template <typename T>
    struct iterator_of_t;

    template <typename T>
    struct iterator1_of_t;

    template <typename T>
    struct iterator2_of_t;

    template <typename T>
    struct array_range_of_t;

    template <typename T>
    struct capacity_type_of_t;

    template <typename T>
    struct size_type_of_t;

    template <typename T>
    struct allocator_type_of_t;

    template <typename T>
    struct auto_type_of_t;

    template <typename T>
    struct key_type_of_t;

    template <typename T>
    struct mapped_type_of_t;

    template <typename T>
    struct node_type_of_t;

    template <typename T>
    struct hasher_of_t;

    template <typename T>
    struct key_equal_of_t;

    template <typename T>
    struct key_compare_of_t;

    template <typename T>
    struct value_compare_of_t;

    template <typename T>
    struct element_of_t;

    template <typename T>
    struct index_of_t;

    template <typename T>
    struct index_gen_of_t;

    template <typename T>
    struct index_range_of_t;

    template <typename T>
    struct left_map_of_t;

    template <typename T>
    struct right_map_of_t;

    template <typename T>
    struct reverse_iterator_of_t;

    template <typename T>
    struct reverse_iterator1_of_t;

    template <typename T>
    struct reverse_iterator2_of_t;

    template <typename T>
    struct ordered_iterator_of_t;

    template <typename T>
    struct handle_type_of_t;

    template <typename T>
    struct expression_type_of_t;

    template <typename T>
    struct type_category_of_t;

    template <typename T>
    struct category_of_t;

    template <typename T>
    struct vertex_descriptor_of_t;

    template <typename T>
    struct edge_descriptor_of_t;

    template <typename T>
    struct vertices_size_type_of_t;

    template <typename T>
    struct edges_size_type_of_t;

    template <typename T>
    struct degree_size_type_of_t;

    template <typename T>
    struct vertex_property_type_of_t;

    template <typename T>
    struct edge_property_type_of_t;

    template <typename T>
    struct vertex_iterator_of_t;

    template <typename T>
    struct edge_iterator_of_t;

    template <typename T>
    struct out_edge_iterator_of_t;

    template <typename T>
    struct in_edge_iterator_of_t;

    template <typename T>
    struct adjacency_iterator_of_t;

    template <typename T>
    struct traversal_category_of_t;

    template <typename T>
    struct directed_category_of_t;

    template <typename T>
    struct edge_parallel_category_of_t;

    template <typename T>
    struct event_filter_of_t;

    template <typename T>
    struct next_to_t;

    template <typename T>
    struct prior_to_t;

    template <typename T>
    struct result_of_t;
}}}  // namespace boost::concept::traits

#else   // !defined(BOOST_NO_CXX11_TEMPLATE_ALIASES)

//[reference__self_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using self_of_t =
        typename ::boost::concept::traits::self_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__tag_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using tag_of_t = typename ::boost::concept::traits::tag_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using type_of_t =
        typename ::boost::concept::traits::type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__const_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using const_type_of_t =
        typename ::boost::concept::traits::const_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__element_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using element_type_of_t =
        typename ::boost::concept::traits::element_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__pointer_element_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using pointer_element_type_of_t =
        typename ::boost::concept::traits::pointer_element_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__result_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using result_type_of_t =
        typename ::boost::concept::traits::result_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__argument_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using argument_type_of_t =
        typename ::boost::concept::traits::argument_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__first_argument_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using first_argument_type_of_t =
        typename ::boost::concept::traits::first_argument_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__second_argument_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using second_argument_type_of_t =
        typename ::boost::concept::traits::second_argument_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__param_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using param_type_of_t =
        typename ::boost::concept::traits::param_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__distribution_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using distribution_type_of_t =
        typename ::boost::concept::traits::distribution_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__policy_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using policy_type_of_t =
        typename ::boost::concept::traits::policy_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__first_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using first_type_of_t =
        typename ::boost::concept::traits::first_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__second_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using second_type_of_t =
        typename ::boost::concept::traits::second_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__num_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using num_type_of_t =
        typename ::boost::concept::traits::num_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__den_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using den_type_of_t =
        typename ::boost::concept::traits::den_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__int_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using int_type_of_t =
        typename ::boost::concept::traits::int_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__value_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using value_type_of_t =
        typename ::boost::concept::traits::value_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_category_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator_category_of_t =
        typename ::boost::concept::traits::iterator_category_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_traversal_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator_traversal_of_t =
        typename ::boost::concept::traits::iterator_traversal_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_difference_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator_difference_of_t =
        typename ::boost::concept::traits::iterator_difference_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_value_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator_value_of_t =
        typename ::boost::concept::traits::iterator_value_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__reference_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using reference_of_t =
        typename ::boost::concept::traits::reference_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__pointer_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using pointer_of_t =
        typename ::boost::concept::traits::pointer_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__container_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using container_type_of_t =
        typename ::boost::concept::traits::container_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__char_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using char_type_of_t =
        typename ::boost::concept::traits::char_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__other_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using other_of_t = typename ::boost::concept::traits::other_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__void_pointer_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using void_pointer_of_t =
        typename ::boost::concept::traits::void_pointer_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_pointer_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using allocator_pointer_of_t =
        typename ::boost::concept::traits::allocator_pointer_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_difference_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using allocator_difference_of_t =
        typename ::boost::concept::traits::allocator_difference_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_size_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using allocator_size_of_t =
        typename ::boost::concept::traits::allocator_size_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_bool_pair_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator_bool_pair_of_t =
        typename ::boost::concept::traits::iterator_bool_pair_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator_of_t =
        typename ::boost::concept::traits::iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator1_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator1_of_t =
        typename ::boost::concept::traits::iterator1_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__iterator2_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using iterator2_of_t =
        typename ::boost::concept::traits::iterator2_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__array_range_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using array_range_of_t =
        typename ::boost::concept::traits::array_range_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__capacity_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using capacity_type_of_t =
        typename ::boost::concept::traits::capacity_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__size_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using size_type_of_t =
        typename ::boost::concept::traits::size_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__allocator_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using allocator_type_of_t =
        typename ::boost::concept::traits::allocator_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__auto_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using auto_type_of_t =
        typename ::boost::concept::traits::auto_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__key_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using key_type_of_t =
        typename ::boost::concept::traits::key_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__mapped_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using mapped_type_of_t =
        typename ::boost::concept::traits::mapped_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__node_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using node_type_of_t =
        typename ::boost::concept::traits::node_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__hasher_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using hasher_of_t = typename ::boost::concept::traits::hasher_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__key_equal_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using key_equal_of_t =
        typename ::boost::concept::traits::key_equal_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__key_compare_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using key_compare_of_t =
        typename ::boost::concept::traits::key_compare_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__value_compare_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using value_compare_of_t =
        typename ::boost::concept::traits::value_compare_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__element_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using element_of_t =
        typename ::boost::concept::traits::element_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__index_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using index_of_t = typename ::boost::concept::traits::index_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__index_gen_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using index_gen_of_t =
        typename ::boost::concept::traits::index_gen_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__index_range_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using index_range_of_t =
        typename ::boost::concept::traits::index_range_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__left_map_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using left_map_of_t =
        typename ::boost::concept::traits::left_map_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__right_map_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using right_map_of_t =
        typename ::boost::concept::traits::right_map_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__reverse_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using reverse_iterator_of_t =
        typename ::boost::concept::traits::reverse_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__reverse_iterator1_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using reverse_iterator1_of_t =
        typename ::boost::concept::traits::reverse_iterator1_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__reverse_iterator2_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using reverse_iterator2_of_t =
        typename ::boost::concept::traits::reverse_iterator2_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__ordered_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using ordered_iterator_of_t =
        typename ::boost::concept::traits::ordered_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__handle_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using handle_type_of_t =
        typename ::boost::concept::traits::handle_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__expression_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using expression_type_of_t =
        typename ::boost::concept::traits::expression_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__type_category_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using type_category_of_t =
        typename ::boost::concept::traits::type_category_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__category_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using category_of_t =
        typename ::boost::concept::traits::category_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__vertex_descriptor_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using vertex_descriptor_of_t =
        typename ::boost::concept::traits::vertex_descriptor_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_descriptor_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using edge_descriptor_of_t =
        typename ::boost::concept::traits::edge_descriptor_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__vertices_size_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using vertices_size_type_of_t =
        typename ::boost::concept::traits::vertices_size_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__edges_size_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using edges_size_type_of_t =
        typename ::boost::concept::traits::edges_size_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__degree_size_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using degree_size_type_of_t =
        typename ::boost::concept::traits::degree_size_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__vertex_property_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using vertex_property_type_of_t =
        typename ::boost::concept::traits::vertex_property_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_property_type_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using edge_property_type_of_t =
        typename ::boost::concept::traits::edge_property_type_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__vertex_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using vertex_iterator_of_t =
        typename ::boost::concept::traits::vertex_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using edge_iterator_of_t =
        typename ::boost::concept::traits::edge_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__out_edge_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using out_edge_iterator_of_t =
        typename ::boost::concept::traits::out_edge_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__in_edge_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using in_edge_iterator_of_t =
        typename ::boost::concept::traits::in_edge_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__adjacency_iterator_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using adjacency_iterator_of_t =
        typename ::boost::concept::traits::adjacency_iterator_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__traversal_category_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using traversal_category_of_t =
        typename ::boost::concept::traits::traversal_category_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__directed_category_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using directed_category_of_t =
        typename ::boost::concept::traits::directed_category_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__edge_parallel_category_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using edge_parallel_category_of_t =
        typename ::boost::concept::traits::edge_parallel_category_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__event_filter_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using event_filter_of_t =
        typename ::boost::concept::traits::event_filter_of<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__next_to_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using next_to_t = typename ::boost::concept::traits::next_to<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__prior_to_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using prior_to_t = typename ::boost::concept::traits::prior_to<T>::type;
}}}  // namespace boost::concept::traits
//]

//[reference__result_of_t
namespace boost { namespace concept { namespace traits {

    template <typename T>
    using result_of_t = typename ::boost::concept::traits::result_of<T>::type;
}}}  // namespace boost::concept::traits
//]

#endif  // BOOST_NO_CXX11_TEMPLATE_ALIASES

#endif  // include guard

