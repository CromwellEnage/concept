// Copyright (C) 2013-2018 Cromwell D. Enage
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

#ifndef BOOST_CONCEPT_TRAITS_INTROSPECTION_NESTED_TYPE_FWD_HPP
#define BOOST_CONCEPT_TRAITS_INTROSPECTION_NESTED_TYPE_FWD_HPP

//[reference__is_self_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_self_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_result_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_result_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_first_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_first_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_second_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_second_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_first_reference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_first_reference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_second_reference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_second_reference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_int_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_int_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_param_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_param_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_num_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_num_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_den_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_den_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_value_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_value_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_node_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_node_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_capacity_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_capacity_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_size_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_size_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_tag_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_tag_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_allocator_pointer_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_allocator_pointer_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_pointer_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_pointer_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_reference_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_reference_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator_bool_pair_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_iterator_bool_pair_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator1_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_iterator1_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator2_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_iterator2_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_local_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_local_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_reverse_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_reverse_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_reverse_iterator1_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_reverse_iterator1_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_reverse_iterator2_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_reverse_iterator2_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_ordered_iterator_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_ordered_iterator_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator_traversal_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_iterator_traversal_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_iterator_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_iterator_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_type_category_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_type_category_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_expression_type_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_expression_type_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_vertex_descriptor_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_vertex_descriptor_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_edge_descriptor_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_edge_descriptor_of;
}}}  // namespace boost::concept::traits
//]

//[reference__is_index_of__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T1, typename T2>
    struct is_index_of;
}}}  // namespace boost::concept::traits
//]

//[reference__has_self__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_self;
}}}  // namespace boost::concept::traits
//]

//[reference__has_tag__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_tag;
}}}  // namespace boost::concept::traits
//]

//[reference__has_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_const_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_const_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_element_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_element_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_result_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_result_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_argument_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_argument_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_first_argument_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_first_argument_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_second_argument_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_second_argument_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_param_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_param_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_distribution_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_distribution_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_first_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_first_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_second_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_second_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_first_param_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_first_param_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_second_param_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_second_param_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_first_reference__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_first_reference;
}}}  // namespace boost::concept::traits
//]

//[reference__has_second_reference__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_second_reference;
}}}  // namespace boost::concept::traits
//]

//[reference__has_policy_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_policy_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_int_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_int_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_num_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_num_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_den_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_den_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_value_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_value_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_iterator_category__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_iterator_category;
}}}  // namespace boost::concept::traits
//]

//[reference__has_iterator_difference__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_iterator_difference;
}}}  // namespace boost::concept::traits
//]

//[reference__has_iterator_value__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_iterator_value;
}}}  // namespace boost::concept::traits
//]

//[reference__has_reference__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_reference;
}}}  // namespace boost::concept::traits
//]

//[reference__has_pointer__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_pointer;
}}}  // namespace boost::concept::traits
//]

//[reference__has_container_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_container_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_char_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_char_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_other__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_other;
}}}  // namespace boost::concept::traits
//]

//[reference__has_void_pointer__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_void_pointer;
}}}  // namespace boost::concept::traits
//]

//[reference__has_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_iterator1__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_iterator1;
}}}  // namespace boost::concept::traits
//]

//[reference__has_iterator2__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_iterator2;
}}}  // namespace boost::concept::traits
//]

//[reference__has_array_range__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_array_range;
}}}  // namespace boost::concept::traits
//]

//[reference__has_capacity_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_capacity_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_size_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_size_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_allocator_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_allocator_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_auto_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_auto_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_key_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_key_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_mapped_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_mapped_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_hasher__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_hasher;
}}}  // namespace boost::concept::traits
//]

//[reference__has_key_equal__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_key_equal;
}}}  // namespace boost::concept::traits
//]

//[reference__has_key_compare__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_key_compare;
}}}  // namespace boost::concept::traits
//]

//[reference__has_value_compare__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_value_compare;
}}}  // namespace boost::concept::traits
//]

//[reference__has_element__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_element;
}}}  // namespace boost::concept::traits
//]

//[reference__has_index__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_index;
}}}  // namespace boost::concept::traits
//]

//[reference__has_index_gen__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_index_gen;
}}}  // namespace boost::concept::traits
//]

//[reference__has_index_range__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_index_range;
}}}  // namespace boost::concept::traits
//]

//[reference__has_left_map__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_left_map;
}}}  // namespace boost::concept::traits
//]

//[reference__has_right_map__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_right_map;
}}}  // namespace boost::concept::traits
//]

//[reference__has_node_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_node_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_reverse_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_reverse_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_reverse_iterator1__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_reverse_iterator1;
}}}  // namespace boost::concept::traits
//]

//[reference__has_reverse_iterator2__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_reverse_iterator2;
}}}  // namespace boost::concept::traits
//]

//[reference__has_ordered_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_ordered_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_handle_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_handle_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_expression_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_expression_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_type_category__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_type_category;
}}}  // namespace boost::concept::traits
//]

//[reference__has_is_view__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_is_view;
}}}  // namespace boost::concept::traits
//]

//[reference__has_category__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_category;
}}}  // namespace boost::concept::traits
//]

//[reference__has_vertex_descriptor__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_vertex_descriptor;
}}}  // namespace boost::concept::traits
//]

//[reference__has_edge_descriptor__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_edge_descriptor;
}}}  // namespace boost::concept::traits
//]

//[reference__has_vertices_size_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_vertices_size_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_edges_size_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_edges_size_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_degree_size_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_degree_size_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_vertex_property_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_vertex_property_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_edge_property_type__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_edge_property_type;
}}}  // namespace boost::concept::traits
//]

//[reference__has_vertex_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_vertex_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_edge_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_edge_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_out_edge_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_out_edge_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_in_edge_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_in_edge_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_adjacency_iterator__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_adjacency_iterator;
}}}  // namespace boost::concept::traits
//]

//[reference__has_traversal_category__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_traversal_category;
}}}  // namespace boost::concept::traits
//]

//[reference__has_directed_category__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_directed_category;
}}}  // namespace boost::concept::traits
//]

//[reference__has_edge_parallel_category__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_edge_parallel_category;
}}}  // namespace boost::concept::traits
//]

//[reference__has_event_filter__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_event_filter;
}}}  // namespace boost::concept::traits
//]

//[reference__has_next__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_next;
}}}  // namespace boost::concept::traits
//]

//[reference__has_prior__fwd
namespace boost { namespace concept { namespace traits {

    template <typename T>
    struct has_prior;
}}}  // namespace boost::concept::traits
//]

#endif  // include guard

